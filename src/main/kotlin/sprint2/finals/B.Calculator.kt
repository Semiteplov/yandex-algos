package sprint2.finals

import java.util.Stack

/*
 * https://contest.yandex.ru/contest/22781/run-report/103691000/
 *
 * Этот алгоритм реализует базовый калькулятор обратной польской записи с использованием стека из коробки.
 * Принцип работы:
 * - Считывает входную строку чисел и операторов.
 * - Числа помещаются в стек.
 * - При встрече оператора алгоритм извлекает необходимое количество операндов из стека,
 *   применяет оператор и возвращает результат обратно в стек.
 * - После выполнения последней операции на вершине стека находится результат.
 *
 * Обоснование корректности:
 * - Алгоритм корректно реализует метод расчета ОПЗ, который является устоявшимся математическим
 *   методом для вычисления выражений без необходимости в скобках.
 * - Каждый оператор корректно выполняет свою математическую функцию над двумя последними числами, что соответствует
 *   логике LIFO.
 * - Специальная обработка случая деления обеспечивает правильное округление результатов при делении отрицательных чисел.
 *
 * Временная сложность:
 * - O(n), где n - количество элементов на входе (как числа, так и операторы).
 * - Каждый элемент обрабатывается ровно один раз.
 *
 * Пространственная сложность:
 * - O(n) в худшем случае, когда все элементы являются числами и хранятся в стеке до любой операции.
 * - Обычно размер стека меньше n, так как операторы уменьшают размер стека.
 */
fun main() {
    val signsMap = hashMapOf<String, (a: Int, b: Int) -> Int>()
    signsMap["+"] = { a, b -> a + b }
    signsMap["-"] = { a, b -> a - b }
    signsMap["*"] = { a, b -> a * b }
    signsMap["/"] = { a, b ->
        if (a < 0 && b > 0 || a > 0 && b < 0) {
            val result = a / b
            if (a % b != 0) result - 1 else result
        } else {
            a / b
        }
    }

    val stack = Stack<Int>()

    val input = readln().split(" ")
    for (s in input) {
        if (signsMap.contains(s)) {
            val last = stack.pop()
            val beforeLast = stack.pop()
            signsMap[s]?.let { stack.push(it(beforeLast, last)) }
        } else {
            stack.push(s.toInt())
        }
    }
    println(stack.peek())
}