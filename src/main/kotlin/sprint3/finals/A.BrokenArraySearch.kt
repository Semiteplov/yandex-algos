package sprint3.finals

/*
    https://contest.yandex.ru/contest/23815/run-report/104265101/

    -- ПРИНЦИП РАБОТЫ --
    Алгоритм основан на модифицированном бинарном поиске.
    В обычном отсортированном массиве бинарный поиск делит массив на половины
    до тех пор, пока не найдет искомый элемент или массив не окажется пустым.
    В данной задаче массив может быть "сломан" - отсортированный массив
    был сдвинут на неизвестное количество позиций. Несмотря на это,
    одна половина разделенного массива всегда будет отсортирована.
    Мы используем этот факт, чтобы определить, в какой половине следует продолжить поиск.
    В данной задаче решил попробовать использовать обычную итерацию, а не рекурсию.

    -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
    При каждом делении массива на две части, одна из них всегда будет отсортированной.
    Мы можем определить, в какой именно половине находится искомый элемент,
    сравнивая его с крайними элементами этой половины.
    Это гарантирует, что если элемент присутствует в массиве, он будет найден.
    Поиск продолжается до тех пор, пока не будет проверена каждая часть массива.

    -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
    Временная сложность алгоритма составляет O(log n), так как на каждом шаге размер
    массива уменьшается вдвое.

    -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
    Пространственная сложность алгоритма составляет O(1), так как весь поиск
    выполняется на месте и не требует дополнительного пространства, кроме
    нескольких переменных для индексов и сравнения.
 */
object Solution {
    fun brokenSearch(arr: IntArray, k: Int): Int {
        var left = 0
        var right = arr.lastIndex

        while (left <= right) {
            val mid = (right + left) / 2

            val midValue = arr[mid]
            if (midValue == k) {
                return mid
            }

            val leftValue = arr[left]
            if (leftValue <= midValue) {
                if (k in leftValue..midValue) {
                    right = mid - 1
                } else {
                    left = mid + 1
                }
            } else {
                val rightValue = arr[right]
                if (k in midValue..rightValue) {
                    left = mid + 1
                } else {
                    right = mid - 1
                }
            }
        }

        return -1
    }
}