package sprint7.finals

/*
    https://contest.yandex.ru/contest/25597/run-report/110999223/

    -- ПРИНЦИП РАБОТЫ --
    1) Проверяем общую сумму очков: если она нечетная, разбиение на две равные части невозможно.
    2) Ищем, возможно ли создать последовательность с суммой, равной половине общей суммы очков.
    3) Если последовательность найдена, то задача решена

    -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
    Используя метод динамического программирования, мы эффективно исследуем все возможные комбинации сумм.
    Поскольку каждый новый элемент учитывается при поиске возможности достижения половины общей суммы, если существует решение, алгоритм его найдет.
    В противном случае, доказательством отсутствия решения служит полный перебор всех вариантов без успешного нахождения нужной суммы.

    -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
    Временная сложность алгоритма O(n * sum / 2), где n - количество партий (элементов), sum - общая сумма очков.
    Это связано с необходимостью проверки каждой возможной суммы до sum / 2 для каждого из n элементов.

    -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
    Пространственная сложность алгоритма составляет O(sum / 2), где sum - общая сумма очков.
    Это обусловлено хранением массива динамического программирования, размер которого равен половине общей суммы очков.
 */
fun main() {
    val n = readln().toInt()

    val scores = readln().split(" ").map { it.toInt() }

    val allSum = scores.sum()

    val isSplitPossible = if (allSum % 2 != 0) {
        false
    } else {
        val halfSum = allSum / 2
        val dp = BooleanArray(halfSum + 1)

        dp[0] = true

        for (score in scores) {
            for (j in halfSum downTo score) {
                if (dp[j - score]) dp[j] = true
            }
        }

        dp[halfSum]
    }

    println(if (isSplitPossible) "True" else "False")
}

